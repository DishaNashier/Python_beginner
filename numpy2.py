# -*- coding: utf-8 -*-
"""NumPy2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1DYcqSDFNXyWCOofwtO_FUm36UVB72twW
"""

#Numpy-2
#-> 2D array(Matrices)
#   reshape using .reshape
#   tranpsose using .T
#-> Indexing/Slicing
#-> Aggreagtion Function
#-> Logical Functions
#-> Fitbit Data Analysis

#Fitbit data analysis
#Smart watches track different data - No of steps
#                                   - Sleep Hours
#                                   - Heart Beat Count
# Given user data we need to analyse the data, and share important insights with the user
# Application- we can take customer oriented decisions

import numpy as np

a=np.arange(16)
a

a.shape,a.ndim

#reshape ->
a.reshape(8,2) # 8 rows and 2 columns

a # we have not stored reshape output in any variable, Therefore value of a remains same

a=a.reshape(8,2)
a

a.reshape(4,4)

a.reshape(4,5)
# total elements here will be 4*5, so total 20 elements but we have only 16 elements in our array therefore it will give error

a.reshape(4,3)
# We have total 16 elements
# Desired Output 4*3 = 12 elements
# ‚ùå Error: cannot reshape array of size 16 into shape (4,3)

a.reshape(16,1)

a.reshape(1,16) #Here we have two square brackets, so this one will be 2D array

a=np.arange(16)
a

# There is difference between both outputs
# array([[ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15]])
# üí°This output is a 2D array
# Concept of rows and columns is present
# Here we have 1 Row and 16 Coumns
# array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15])
#üí°This output is a 1D array
# No concept of rows and columns

#We can add one unknown dimension
a.reshape(-1,8)
# When we want 8 columns and want data to be distributed automatically in rows we will use -1 in rows position

a.reshape(4,-1)
# Here we want 4 rows and automatic assignments of columns

#We can only specify one unknown dimension
a.reshape(-1,-1)

len(a)#number of elemets in first dimension, index 0

a=a.reshape(-1,2)
a

len(a) #number of elements in first dimension

a.shape

a[0]

a[1]

len(a[-1])

a

#Transpose an Array
a.T

a=np.arange(10,19).reshape(3,3)

a

# print first row 1
a[0]

# print last row
a[-1]

# TO extract first element from 1st row
# extract 10 from a
a[0][0]

# extract 15 from aaray a
a[1][2]

# extract 15 from aaray a
a[1][-1]

a[0,0]
# we can directly remove repetation of [][], reference- above code
# so we write the index position "," seperated

# How will you extract 16,17,18 and 10,11,12
# If you want to extract multiple elements you have to give it in form of list
# Same we do in case of list
a[[2,0]]

a[2,0]

#Slicing in 2D array
m1=np.arange(20).reshape(4,5)
m1

m1[:2]

m1[2:]

m1[2:]

m1[-2:]

# a[row slicing, col slicing]

m1[:3,2:4]

m1[2:,1:]

m1[1:3,:2]

# last 2 rows and 2 columns
# Generic code - for every matrix
m1[-2: ,-2:]

#@title Fancy Indexing/ Masking

m1

m1<10 # We will get boolean array

m1[m1<10]

#o/p is 1D?
m1[m1%2==0]

# o/p is 1D because it is not evident that how many values we will get in output, it can be any number
# Reshaping can be done after geting the output

m1[m1%2==0].reshape(5,2)

a=np.array([0,1,2,3,4,5])
mask=(a%2==0)
a[mask]=-1

a

a=np.array([0,1,2,3,4,5])
a[a%2==0]=-1
a

#Aggregation Function

np.sum(a)

a=np.arange(1,6)
a

np.sum(a)

np.mean(a)

np.min(a)

np.max(a)

a.size

15/5

import numpy as np

m1=np.arange(20).reshape(4,5)
m1

np.sum(m1)

m1.sum()

np.mean(m1)

m1.ndim

m1.size

m1.shape

# to sum elements based on axis
# m1.shape -> (4,5)  shows that first axis(number of array=4, index=0)
#                    second axis (size of array=5, index=1)

np.sum(m1,axis=1) #row wise sum/ sum of each individual array in matrix

np.sum(m1,axis=0) #col wise sum/ sum of elements at same index positions in each array

np.mean(m1,axis=1)

np.mean(m1,axis=0)

#any/all

# np.any(bool array) # atleast one element needs to be True,else False
# np.all(bool array) # all the elements need to be True, else False

# we want to check if we can afford product on given prices
prices=np.array([50,45,25,20,35])
budget=30
can_afford=budget>prices
can_afford

#If we want single answer True or False
# We can use np.any (at least one item need to be T/F)
prices=np.array([50,45,25,20,35])
budget=30
can_afford=np.any(budget>prices)
can_afford

prices=np.array([50,45,25,20,35])
budget=30
can_afford=np.any(budget>prices)
if can_afford == True:
  print("You can buy atleast 1 item from your list")
else:
  print("Low on budget")

prices=np.array([50,45,25,20,35])
budget=30
can_afford=np.all(budget>prices)
if can_afford == True:
  print("You can buy atleast 1 item from your list")
else:
  print("Low on budget")

# np.where(condition,x,y)
# condition : When True, yield x, otherwise yield y.
prices=np.array([50,45,25,20,35])
budget=30
can_afford=np.where(prices<budget,prices,False)
can_afford

# np.where(condition,x,y)
# condition : When True, yield x, otherwise yield y.
# If both x and y are specified, the output array contains elements of x where condition is True, and elements from y elsewhere.
prices=np.array([50,45,25,20,35])
budget=30
can_afford=np.where(prices<budget,prices,budget)
can_afford

# np.where(condition,x,y)
# If only condition is given, return the tuple condition.nonzero(),
# the INDICES where condition is True.
prices=np.array([50,45,25,20,35])
budget=30
can_afford=np.where(prices<budget)
can_afford

# Note:
# flatten() function is used to transform a multi-dimensional array into a one-dimensional array.
# In other words, it "flattens" a multi-dimensional array structure into a simple linear sequence.
import numpy as np
a = np.array([[16, 5], [81, 6], [33, 1]])
x=np.transpose(a).reshape(2,3)
print(x.flatten())

#@title FitBit Data Analysis

#EDA -> Exploratory Data Analysis
!gdown https://drive.google.com/uc?id=1vk1Pu0djiYcrdc85yUXZ_Rqq2oZNcohd

data=np.loadtxt('/content/fit.txt',dtype='str')

data.shape

data.ndim

# Date
# Step count
# Mood
# Calories Burned
# Hours of sleep
# Activity status

data[0]

data[-1]

data[:5]

date,step_count,mood,calories_burned,hour_of_sleep,activity_status=data.T

date

step_count

step_count=step_count.astype('int')
step_count

np.mean(step_count)

hour_of_sleep

hour_of_sleep=hour_of_sleep.astype('int')
np.mean(hour_of_sleep)

hour_of_sleep[hour_of_sleep>7]

#When mood is happy what is the step count
step_count[mood=='Happy'].mean()

step_count[mood=="Sad"].mean()

hour_of_sleep[mood=='Happy'].mean()

hour_of_sleep[mood=='Sad'].mean()

mood[step_count>4000]

#select step_count from fitbit where stepcount>4000
step_count[step_count>4000]


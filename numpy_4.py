# -*- coding: utf-8 -*-
"""NumPy_4.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1GrnywPuQZUw1LkHGExGLkA47G6LkQIes
"""

# Topics Covered
# Deep copy and shallow copy
# Copy- is the new array
#       is physically stored at another Location
# View/Shallow copy- view of original array
#       has the same memory location as the original array
# .copy() to create deep copy
# .view() to create shallow copy
# Note- When we make changes to the view it affects the original array, and when changes are made to the original array it affects the view.
# Spliting- spliting arrays horizontally and vertically
# Stacking- horizontal stacking and vertical stacking
# Dimension expansion and reduction

import numpy as np
a=np.array([0,1,2,3])

b=a #shallow copy

b[0]=100  #changes made in shallow copy

b

a # value of a also changed automatically in original array

c=a.reshape(2,2) #shallow copy of original array beacuse we are changing only shape no mathematical calculation

c

c[0]=200 # change in shallow copy

c

a #again value of original array got changed

a[3]=300 #change in original array value

a

c #change in shallow copy is seen

a=np.arange(4) #new original array created

c=a+2  #mathematical calculations done using original array

c # value of c after a+2

a  #no change in array a because of calculations performed

a[0]=100 #change in original array "a"

c # changes are not reflected in c because c array is assigned to different memory location

#shallow copy only works if you are not doing any mathematical calculations
# it will only work for smaller cases
# if you change only shape of data
# if you change only data type
# if you assign as it is value

np.shares_memory(a,c)

a

b=a

np.shares_memory(a,b)

a

c=a

c=a+2 # as soon as we make edit to our local copy
      #it will be assigned to a different location

np.shares_memory(a,c)

# if any edit is going to happen- no shallow copy - new copy
# if i use same data and perform simpler operations like reshape - SHALLOW COPY
# if i making some changes or edits to data - DEEP COPY

a=np.arange(10)

a

b=a[::2]

b # b contains meta data, new memory will not be allocated

a

b[1]=100

b

a
# we can see that in original list also same value changed"2" -> "100"
# in list "b" we chnaged at index 1
# in list "a" it got changed where value was stored

b

a=np.arange(6)

b=a[a%1==0] #because we are doing some calculations/operations it will be stored in new memory

b

np.shares_memory(a,b)

a=np.array([0,2,1,3,5,4])

b=a[a%2==0]
# Masking is performed
# because calculation is required it will create a DEEP COPY

b

a=np.arange(10)

b=a.copy() #Deep copy

np.shares_memory(a,b)

a=np.arange(10)

b=a.view() #shallow copy

b

np.shares_memory(a,b)

a=np.array([0,1,2,3,4,5])
b=a[a%1==0] #any type of masking it will create deep copy
b[0]=10
a[:2]

arr=np.arange(10)

a=arr.view()

a[0]=100

arr

arr=np.array([1,'m',[1,2,3]],dtype='object')
arr

copy_arr=arr.copy()

copy_arr

copy_arr[2][0]=999

copy_arr

arr #for data type object .copy() is not working at all, even after creating deep copy chnages in copy_arr are reflecting in arr

import copy

arr=np.array([1,'m',[1,2,3]],dtype='object')

copy=copy.deepcopy(arr)

copy[2][0]=999

copy

arr

x=np.arange(9)

x

# np.split used for spliting a numpy array into n number of arrays
np.split(x,3)

c=np.arange(16)

c

np.split(c,[3]) # split upto an index postion than provide index in []

np.split(c,[3,5]) #spliting happens at 3 index, 5th index,

np.split(c,[3,5,6]) #spliting happens at 3 index, 5 index, 6 index

x=np.arange(16.0).reshape(4,4)

x

#@title Horizontal and Vertical split

# 1. Horizontal Spliting

np.hsplit(x,2) # divide into two equal parts

np.hsplit(x,[1]) #divide based on index position

# 2. Vertical spliting
np.vsplit(x,2) #split into two equal parts

np.vsplit(x,[1]) #split based on index position

np.vsplit(x,[1])

# @title Stacking(Horizontal and Vertical)

a=np.arange(1,5)
b=np.arange(2,6)
c=np.arange(3,7)

a

b

c

# vertical stacking
np.vstack([a,b,c])

a=np.array([[1],[2],[3]])
b=np.array([[4],[5],[6]])
np.vstack((a,b))

# Horizontal Stacking
a=np.arange(5).reshape(5,1)

b=np.arange(15).reshape(5,3)

a

b

np.hstack([a,b])

np.hstack((a,b))

a=np.array([[1],[2],[3]])
b=np.array([[4],[5],[6]])
np.hstack((a,b))

a=np.array([[1,2,3]])
b=np.array([[1,2,3],[4,5,6]])

a

b

np.concatenate([a,b],axis=0) #vertical stacking

a=np.arange(6).reshape(3,2)
b=np.arange(9).reshape(3,3)

a

b

np.concatenate((a,b),axis=1) #horizontal stacking

a=np.array([[1,2],[3,4]])
b=np.array([[5,6,7,8]])

a

b

np.concatenate((a,b),axis=None) # axis= None to concatenate 2D lists into 1D list

a=np.array([[1,2],[3,4]])
b=np.array([[5,6]])
np.concatenate((a,b.T),axis=1)

# dimension expansion and reduction

ar=np.arange(6)

ar.shape

# Dimension expansion
# using reshape
b=ar.reshape(1,-1)

b.shape

b

arr=np.arange(6)

arr.shape

# using (expand_dims, axis =1)
b=np.expand_dims(arr,axis=1)

b.shape

# using (expand_dims, axis=0)
b=np.expand_dims(arr,axis=0)

b.shape

arr=np.arange(6)

b=arr[np.newaxis,:]

b.shape

b=arr[:,np.newaxis]

b

b=arr[:,None]

b.shape

b=arr[None,:]

b

#Dimension reduction

arr=np.arange(9).reshape(1,1,9)

arr.shape

arr1=np.squeeze(arr)

arr1.shape

arr.shape

arr1=np.squeeze(arr,axis=1)

arr1.shape

arr1=np.squeeze(arr,axis=0)

arr1.shape

